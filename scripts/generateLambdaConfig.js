const fs = require('fs');
const path = require('path');
const klaw = require('klaw');
const yaml = require('js-yaml');
const { promisify } = require('util');

const SEARCHPATH = process.argv[2] || '..';

const writeYaml = async (path, obj) =>
  promisify(fs.writeFile)(
    path,
    '# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. RUN scripts/generateLambdaConfig TO REGENERATE\n\n' +
      yaml.dump(obj),
    {
      encoding: 'utf8',
    }
  );
const capitalise = (str) => str.charAt(0).toUpperCase() + str.slice(1);

const filter = (item) => {
  const basename = path.basename(item);
  return (
    (basename === '.' || basename[0] !== '.') && basename !== 'node_modules'
  );
};

const describeDataSource = (funcName) => ({
  Type: 'AWS::AppSync::DataSource',
  Properties: {
    ApiId: '${self:custom.appsyncId}',
    Description: `${funcName} lambda handler for \${self:service}, Edu-pal`,
    LambdaConfig: {
      LambdaFunctionArn: {
        'Fn::GetAtt': [`${capitalise(funcName)}LambdaFunction`, 'Arn'],
      },
    },
    ServiceRoleArn: {
      'Fn::GetAtt': ['AppSyncLambdaRole', 'Arn'],
    },
    Type: 'AWS_LAMBDA',
    Name: `${funcName}Lambda`,
  },
});

const describeResolver = (funcName, typeName) => ({
  Type: 'AWS::AppSync::Resolver',
  Properties: {
    ApiId: '${self:custom.appsyncId}',
    FieldName: funcName,
    RequestMappingTemplate:
      '${file(resources/variableResolver.js):requestMappingTemplate}',
    ResponseMappingTemplate:
      '${file(resources/variableResolver.js):responseMappingTemplate}',
    TypeName: typeName,
    DataSourceName: {
      'Fn::GetAtt': [`${capitalise(funcName)}DataSource`, 'Name'],
    },
  },
});

const describeFunction = (funcName, funcPath) => ({
  handler: funcPath,
  role: {
    'Fn::GetAtt': ['LambdaRole', 'Arn'],
  },
  tags: {
    project: 'edupal',
    service: '${self:service}',
    component: 'lambda',
  },
});

/**
 * Traverse given path and find all index.ts files
 * For each ts file:
 * 	Create lambda function
 * 	Create lambda data source
 * 	Create lambda mapping
 * @param searchPath string
 * @param writePath string
 */
const generateLambdaConfig = (
  searchPath = SEARCHPATH,
  writePath = searchPath + '/resources'
) => {
  // Function executes with script/ dirname, must 'cd' back to root
  searchPath = path.join(__dirname, '..', searchPath);
  writePath = path.join(__dirname, '..', writePath);
  let functionConfig = {};
  let resourceConfig = {};

  klaw(searchPath, { filter })
    .on('data', ({ path: foundPath }) => {
      if (path.basename(foundPath) !== 'index.ts') return;
      // Gets name of folder encapsulating index.ts as function name
      const pathArr = foundPath
        .replace(searchPath, '')
        .replace('.ts', '.handler')
        .split('/');
      const funcName = pathArr.slice(-2, -1).join('');
      const funcPath = pathArr.slice(1).join('/');
      if (!['queries', 'mutations'].includes(pathArr[1])) return;
      const typeName = pathArr[1] === 'mutations' ? 'Mutation' : 'Query';

      resourceConfig = {
        [`${capitalise(funcName)}DataSource`]: describeDataSource(funcName),
        [`${capitalise(funcName)}Resolver`]: describeResolver(
          funcName,
          typeName
        ),
        ...resourceConfig,
      };
      functionConfig = {
        [funcName]: describeFunction(funcName, funcPath),
        ...functionConfig,
      };
    })
    .on('error', (err, { path }) => {
      throw new Error(`At ${path}: ${err}`);
    })
    .on('end', async () => {
      await writeYaml(`${writePath}/functions.yml`, functionConfig);
      await writeYaml(`${writePath}/appsync.yml`, {
        Resources: resourceConfig,
      });
    });
};

generateLambdaConfig();
module.exports = generateLambdaConfig;
